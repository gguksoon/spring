============================================[0909]============================================

ㅁ 스프링 설정파일 
   - .java파일
   - .xml + .java 
   - .xml파일
	> sts ==> https://spring.io/tools3/sts/all ==> windows 다운로드
	> B_Util - 3.Eclipse - sts-bundle - sts-3.9.9.RELEASE - STS.exe를 바탕으로
	> 경로: E:\A_TeachingMaterial\7.JspSpring\springworkspace

   - 201906eclipse에서 export - preferences - Export all 체크하고 
     파일명 jspsetting으로 finish

   - sts에서 import - preferences - Import all - 아까 export한 파일 선택 finish

   - sts를 사용하는 가장 큰 이유 ==> bean 선언하기에 편함(위자드를 제공함)

ㅁ Framework와 library의 차이
   - Library: 프로그램 호출에 의한 제어
	      정의된 대로 사용 ==> logger.debug()
              원본 Library 재정의 가능

   - Framework: 프로그램의 흐름이 프레임워크에 의해 제어
                기능 확장 가능
                Framework 자체는 수정불가(수정은 가능하지만 원본기능이 작동하지 않을 수 있다)

   - Framework를 사용하는 이유
	> 시스템의 기능외에 필요한 비기능 요소들을 제공받을 수 있다.
	  ==> 시스템 구축시마다 반복적으로 비기능 요소를 구현할 필요가 없다.
	      (비기능: DB connection 관리, transaction 제어)
	      (기능: 인사시스템의 사원정보 저장/조회/변경, 상담 시스템의 상담 내용 입력)
	> 비지니스 로직 구현에 집중할 수 있다.
	> 비기능 요소들을 직접 구현할 자신이 없다.

	> 장점: 구현/유지보수의 편이
	> 단점: 개발자들의 역량 획일화

	> 즉, 개발자들이 비지니스 로직에만 집중할 수 있도록 지원한다. 





============================================[0910]============================================

★ 현재 가지고 있는 지식으로 이해할 수 있도록 코드 작성 ★

ㅁ IOC(Inversion of Control): 제어의 역전, 모든 종류의 작업을 사용하는 쪽에서 제어

ㅁ 프로젝트 생성: 
   1. 위자드 - maven project - create a simple project 체크 -
      kr.or.ddit / spring / 0.0.1-SNAPSHOT / war - finish
   2. 프로젝트 우클릭 - java ee - generate deployment~~ - 생성된 web.xml의 버전을
      2.5에서 3.0으로 변경

ㅁ 테스트 코드 ==> 컨테이너를 사용하지만, 직접 만드는건 이번이 처음(예시임)
   - src/test/resources/kr/or/ddit/spring/ioc에서 Spring Bean Configuration File
     => application-context-test.xml
	<!--  name: 스프링 컨테이너에서 관리되는 객체의 이름 - 개발자가 작성 -->
	<!-- class: 해당 스프링 객체의 구현 클래스의 full name -->
	<bean name="boardDao" class="kr.or.ddit.test.board.dao.BoardDao"/>

	<!-- boardService라는 이름으로  kr.or.ddit.test.board.service.BoardService 클래스를 이용하여 스프링객체 생성-->
	<!-- BoardService 클래스의 boardDao필드(<property name>)에 boardDao라는 이름의 스프링 빈(<property ref>)을 주입 -->
	<bean name="boardService" class="kr.or.ddit.test.board.service.BoardService">
		<property name="boardDao" ref="boardDao"/>  <!-- 위에 적힌 boardDao를 주입 -->
		<property name="boardNm"  value="Q/A게시판"/> <!-- 문자열 Q/A게시판을 주입 -->
	</bean>

   - src/test/java/kr/or/ddit/board/dao => IBoardDao.java / BoardDao.java

   - src/test/java/kr/or/ddit/board => Main.java
	1. spring ioc 컨테이너를 이용한 객체 생성(객체를 만드는 설명서를 spring한테 위임)
	ApplicationContext context = new ClassPathXmlApplicationContext
		("classpath:kr/or/ddit/spring/ioc/application-context-test.xml");

	2. 스프링 컨테이너로(==ioc 컨테이너)부터 원하는 객체를 요청: DL(Dependency Lookup)
	IBoardDao cDao = (IBoardDao)context.getBean("boardDao");
	IBoardService cService = context.getBean("boardService", IBoardService.class);

ㅁ boardDao 구현체를 설정할 수 있는 방법
   1. 직접 만들기
	==> 생성자에서 new BoardDao() <-- jsp시간에 했으나 좋은 방식이 아님(분리가 힘듦)
   2. 외부에서 주입 
	==> .setter( setBoardDao(IBoardDao boardDao) )
	==> .constructor( public BoardService(IBoardDao boardDao) )

ㅁ DI(Dependency Injection): 컨테이너가 빈 설정 정보를 바탕으로 의존성을 고려하여
	객체(bean)를 주입 => XML, java annotation 설정
	ex) boardService에 boardDao 객체 주입 => 많이 사용

ㅁ DL(Dependency Lookup): 컨테이너에 설정된 빈을 참조
	ex) applicationContext객체로 부터 boardService객체를 참조 => 잘 사용 안함

ㅁ 명시적 트랜잭션: 개발자가 직접 commit하는 것 ==> sqlSession.commit();
   선언적 트랜잭션: 특정 예외시 자동으로 rollback, 아니면 commit

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

★ 앞으로 사용할 spring 코드 작성 ★

ㅁ Spring Annotation ==> junit 예시

// @Test 메소드가 실행되기 전에 제공한 조립 설명서를 바탕으로 스프링 컨테이너를 구축
// @Resource을 이용해서 junit클래스의 필드에 스프링 빈을 손쉽게 주입받을 수 있다.
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:kr/or/ddit/spring/ioc/application-context-test.xml")
public class SpringContainerTest {

	// name: 스프링 빈 이름
	// boardDao라는 이름의 스프링 빈을 스프링 컨테이너로부터 찾아 boardDao필드에 주입
	@Resource(name="boardDao")
	private IBoardDao boardDao;
	
	@Test
	public void boardDaoBeanTest() {
		assertNotNull(boardDao);
	}
}

ㅁ Bean의 scope ==> 기본값은 singleton
   - singleton: bean을 컨테이너에 하나씩만 생성
		spring컨테이너에서 같은 이름의 bean은 하나만 존재
		(디자인 패턴과 다르게 같은 클래스에서 다른 이름(id == name)을 갖는
		스프링 빈이 존재 가능)
   - prototype: bean을 요청할 때 마다 새로운 빈을 생성
   - request: http request마다 생성(WebApplicationContext에만 적용)
   - session: http session당 하나의 객체를 생성(WebApplicationContext에만 적용)

   * 4가지가 있지만, singleton만 사용함

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ annotation-base
   - 모든 빈을 명시적으로 기술하는데는 비용이 크다.
   - base패키지 하위에 속한 클래스 중 @Controller, @Service, @Repository, @Component
     어노테이션이 설정을 확인하여 spring bean으로 자동으로 등록해준다.
   - annotation-config를 통해 다음의 어노테이션을 처리하는 BeanPostProcessor 등록을
     간편하게 할 수 있다.

<beans ......>
	<context:component-scan base-package="kr.or.ddit, kr.or.ccit"/>

	<!-- 스캔 이후에 @Resource 어노테이션에 대한 후처리 -->	
	<context:annotation-config/>

	<!--
	  <bean>엘레멘트를 이용하여 스프링 빈으로 등록하던 방식에서 
	  특정 패키지 이하의 클래스를 스캔하며 @Controller, @Service, @Repository, @Component
	  어노테이션이 붙은 클래스들을 자동으로 스프링 빈으로 생성
	 -->
	<context:component-scan base-package="kr.or.ddit"/>

	<!--
	   스캔 이후에 @Resource, @Autowired, @Qualifier, @Required,
	   @PostConstruct, @PreDestory, @Configuration 어노테이션에 대한 후처리
	   (수업시간엔 대부분 @Resource만 사용할 예정) 
	-->	
	<context:annotation-config/>
</beans>

   * @Resource(name="boardDao") <== BoardDao클래스를 사용하는 방법(첫글자 소문자)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ 자바 클래스를 스프링 설정파일로 만들기
   * component-scan을 사용하는 것과 자바 클래스를 사용하는 두 가지 방법에 대해
     알고 있어야 한다.

	@Configuration
	@ComponentScan(basePackages = "kr.or.ddit")
	public class ApplicationJavaConfigScanT1 { } 
	


	@RunWith(SpringJUnit4ClassRunner.class)
	@ContextConfiguration(classes = ApplicationJavaConfigScanT1.class)
	public class ApplicationJavaConfigScanT1Test { 

		@Resource(name="userDao")
		private IUserDao userDao;	
	}



============================================[0911]============================================

ㅁ spring에서의 형변환 문제
   - xml 설정 파일에서 value속성을 주입할 때
     <bean id="xxx" class="zz.aa.Class">
	<property name="userId" value="brown"/>
	<property name="reg_dt" value="2019-08-08"/>
     </bean>

   - spring web mvc모듈에서 파라미터를 command객체(from객체, vo)로 자동 바인딩시
     형변환 문제가 발생(파라미터는 문자열 -> command객체의 date필드에 주입)

   - 해결책 3가지
	> propertyEditor
	> conversionService
	> formatting conversionService <-- 주로 사용함

ㅁ propertyEditor (kr.or.ddit.type => CustomDatePropertyEditor.java)
   - 클래스에 PropertyEditorRegistar인터페이스 구현하기
   - quick pix를 통해 registerCustomEditors메서드를 생성
   - 메서드 내부에 
	registry.registerCustomEditor(
		Date.class, new CustomDateEditor(
			new SimpleDateFormat("yyyy-MM-dd"), true
		)
	);
   - bean
	<bean name="customEditorConfigurer" class="org.springframework.beans.factory.config.CustomEditorConfigurer">
		<property name="propertyEditorRegistrars">
			<list>
				<bean class="kr.or.ddit.type.CustomDatePropertyEditor"/>
			</list>
		</property>
	</bean>

ㅁ conversionService (kr.or.ddit.type => CustomDateConverter.java)
   - bean
	<bean name="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
		<property name="converters">
			<set>
				<bean class="kr.or.ddit.type.CustomDateConverter"/>
			</set>
		</property>
	</bean>
   - 클래스에 Converter<String, Date>인터페이스 구현하기
		==> org.springframework.core.convert.converter.Converter   
   - quick pix를 통해 convert메서드를 생성
   - 메서드 내부에
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		
	try {
		return sdf.parse(source);
	} catch (ParseException e) {
		e.printStackTrace();
	}
	
	return null;

ㅁ formatting conversionService
   - bean
   <bean name="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
   
   - vo
   @DateTimeFormat(pattern="yyyy-MM-dd")
   private Date reg_dt;

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

★ IOC 끝

1. 프로젝트 신규생성
2. pom, gitignore, logback.xml 설정파일 복사
3. userDao, userService
   - xml: <bean>, scan
   - java: @Bean, scan

★ 위 사항의 테스트코드를 정상적으로 생성하여 테스트 코드를 통과하게끔 연습할 것

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ AOP(Aspect Oriented Programming): 여러 클래스로 분산된 책임(기능)을 별도의 관점
				     으로 분리/캡슐화 하는 프로그래밍 방법
   - 로직을 실행하기에 앞서 넣어주고 싶은 비기능 로직을 작성하지 않고 개발한 뒤
     AOP가 알아서 소스코드에 비기능 로직을 넣어서 컴파일? 시켜준다.
   - AOP는 OOP(객체지향프로그래밍)를 대체하는 개념이 아닌 보완하는 개념

   - pom.xml
	<!-- AOP: https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
	<dependency>
		<groupId>org.aspectj</groupId>
		<artifactId>aspectjweaver</artifactId>
		<version>1.9.4</version>
	</dependency>

   - ProfilingAspect.java
	public void befor(JoinPoint joinPoint) { // ==> org.aspectj.lang.JoinPoint
		logger.debug("profilingAspect.befor()");
	}

   - application-context-aop-test.xml

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ 트랜잭션
   - 선언적 트랜잭션 관리
	> 소스코드상에서 트랜잭션을 제어하지 않음
	> 설정을 통해 일괄적으로 트랜잭션을 제어(xml: tx, java: annotation)

ㅁ jdbc
   - pom.xml
	<!-- mybatis: https://mvnrepository.com/artifact/org.mybatis/mybatis -->
	<dependency>
		<groupId>org.mybatis</groupId>
		<artifactId>mybatis</artifactId>
		<version>3.5.2</version>
	</dependency>

	<!-- mybatis-spring: https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->
	<dependency>
		<groupId>org.mybatis</groupId>
		<artifactId>mybatis-spring</artifactId>
		<version>2.0.2</version>
	</dependency>

	<!-- dbcp: https://mvnrepository.com/artifact/org.apache.commons/commons-dbcp2 -->
	<dependency>
		<groupId>org.apache.commons</groupId>
		<artifactId>commons-dbcp2</artifactId>
		<version>2.7.0</version>
	</dependency>

   - context-datasource.xml <== src/main/resource /kr/or/ddit/config/spring
	// namespaces: context
	<context:property-placeholder location="classpath:kr/or/ddit/config/mybatis/db.properties"/>
	<bean name="datasource" class="org.apache.commons.dbcp2.BasicDataSource">
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.user}"/>
		<property name="password" value="${jdbc.pass}"/>
	</bean>

	<bean name="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="datasource"/> <!-- bean 주입 -->
		<property name="configLocation" value="classpath:kr/or/ddit/config/mybatis/mybatis-config.xml"/>
	</bean>
	
	<bean name="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
		<constructor-arg ref="sqlSessionFactory"/>
	</bean>

   - context-transaction.xml <== src/main/resource /kr/or/ddit/config/spring
	// namespaces: aop, tx
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="datasource"/> <!-- datasource는 context-datasource.xml에 있음 -->
	</bean>
	
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<!-- 메소드 이름별로 트랜잭션에 대한 세부설정 -->
			<tx:method name="*" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>

	<aop:config>
		<aop:advisor advice-ref="txAdvice" pointcut="execution(* kr.or.ddit..service.*.*(..))"/>
	</aop:config>

   - context-root.xml <== src/main/resource /kr/or/ddit/config/spring
	// namespaces: context
	<context:component-scan base-package="kr.or.ddit">
	</context:component-scan>
	
	<context:annotation-config/>





============================================[0916]============================================

ㅁ 개발자 전용 DB
   - 개발자가 로직을 실행했을 때 다른 개발자들과 기획자들에게는 영향이 가지 않도록
     혼자만 사용하는 DB
   - 운영 DB에서 개발시 insert, delete, update로직에 대한 테스트를 정확하게 하지
     못할 가능성이 높아진다.
   - 개발자 피씨에 설치, 해당 개발자 혼자 사용하는 DB

ㅁ 테스트 DB
   - 많은 개발자들이 작성한 로직을 하나의 테스트 서버에 배포하고 관련자들(개발자, 
     기획자, 디자이너, PM, PL)이 개발 진행사항을 테스트 목적으로 사용하는 DB
   - 중간프로젝트에서 사용한 DB

ㅁ 운영 DB
   - 실제 서비스를 운영하면서 사용하는 DB
   - 여기에는 테스트 목적의 데이터가 들어가면 안된다.
   - 개발자들은 운영 DB 접속 계정을 부여 받지 못하는 경우도 많음
	> DBMS 특성상 임의의 sql이 실행될 경우 성능에 치명적인 영향을 줄 수도
	  있고, 서비스가 다운될 수 있다.

* 테스트 코드를 실행 시(insert, delete) 기존 데이터에 영향을 준다.
   - SEM: 운영 - 테스트코드를 실행할 때는 사용하지 않아야 한다.
   - SEM-TEST(PC-02-TEST): 테스트 목적으로 계정을 신규로 생성
* 불편함이 존재: 새로운 table을 생성할 경우 test계정에서 생성, 개발 후 문제가
  없으면 운영 DB에도 해당 table을 생성해주는 과정이 필요

ㅁ DB 쿼리문
	-- 테이블 스페이스 정보 확인
	SELECT *
	  FROM DBA_DATA_FILES;
  
	-- 테이블 스페이스 생성
	CREATE TABLESPACE TS_201904_TEST
	     DATAFILE 'E:\B_UTIL\4.ORACLE\APP\ORACLE\ORADATA\XE\TS_201904_TEST.DBF'  -- 위 select문을 실행하여 나오는 file_name의 경로
	     SIZE 100M 
	     AUTOEXTEND ON;
	
	-- 사용자 생성
	CREATE USER JMS_TEST IDENTIFIED BY java
	     DEFAULT TABLESPACE TS_201904_TEST;
	
	-- 접근권한 등의 리소스를 생성
	     GRANT CONNECT, RESOURCE TO JMS_TEST;

	-- 테이블 스페이스 같은 경우는 기존의 경로에 해도 되지만, 생성함

ㅁ 위 쿼리문 실행 후
   새 접속 -> 접속이름: JMS_TEST / 사용자이름: JMS_TEST/ 비밀번호: java

ㅁ 새로 생성된 테이블 스페이스에 기존 테이블 스페이스를 복사해줘야 한다.
   - 방법1. 급할 때 사용(제약조건 복사 안됨)
	-- 기존 DB 조회
	select *
	  from jms.users;

	-- ctas: create table as ==> 데이터만 복제, 제약조건(PK, FK)
	create table jms_test.users as
	select *
	  from jms.users;

	-- 복제된 DB 조회
	select *
	  from jms_test.users;

	-- 테이블 삭제
	drop table jms_test.users;

   - 방법2.쿼리문으로 출력
	해당 테이블 우클릭 - 익스포트 - 스키마 표시 해제 / 저장 영역 해제 - 완료

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ UserService의 Test코드의 경우 유저의 변동사항이 문제가 될 수 있다.
   ==> setup()에 데이터를 삭제하고 다시 쿼리문을 실행해주도록 해준다.
   ==> ResourceDatabasePopulator를 사용

   ==> kr.or.ddit.user.service UserServiceTest.java

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ 실습: buyer, lprod, prod 이관
   1. 운영DB(JMS) ==> 테스트DB(JMS_TEST)로 복사
   2. LPROD 이관
   3. LPROD TEST 이관

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ Spring MVC

ㅁ MVC 흐름
   - 모든 요청은 DispatcherServlet이 받는다.
   - Handler Mapping을 통해 요청을 처리할 controller를 찾는다.
   - Handler Adapter를 통해 controller의 메소드 인자를 준비한다.
	> Servlet과 다르게 메소드 인자를 비교적 자유롭게 설정 가능하다.
	  ex) response객체가 필요 없다면 메소드 인자에서 제거 가능하다.
   - Controller를 실행(service -> dao), view에서 사용할 속성을 model에 저장하고 viewName을 리턴
	> View객체, ModelAndView객체, collection객체가 리턴 타입이 될 수도 있고,
	  void도 가능하다.
   - viewResolver를 통해 응답을 생성할 view객체를 결정
	> viewResolver는 viewName을 이용하여 처리할 View를 매핑
	> spring은 view에 의존적이지 않다.
   - 해당 View객체를 통해 응답 생성
	> 응답을 생성하는 view는 jsp뿐만 아니라 json, xml도 있다.
	  (화면은 없고 데이터만 존재하는 경우)
	> model객체에 담긴 속성은 request에 담는 작업이 이루어진다.

ㅁ MVC 시작하기
   - pom.xml 설정하기(spring-mvc, spring-mvcweb)
   - web.xml 설정하기
	> ctrl + space -> contextloaderlistener
	> ctrl + space -> dispatcherservlet
   - servlet-context.xml 설정하기
	> context-root.xml <== /src/main/resources/kr/or/ddit/config/spring
	> servlet-context.xml <== /src/main/resources/kr/or/ddit/config/spring

ㅁ MVC 시작하기(사전지식)
   - spring container에는 계층 구조를 설정할 수 있음
	> 자식 컨테이너는 부모 컨테이너의 스프링 빈을 참조할 수 있음
	  (java의 상속과 동일, 부모는 자식 사용불가, 자식은 부모 사용가능)
	> root container(부모)에는 service bean과 dao bean이 들어감

ㅁ servlet-mapping 처리과정
   - 서버가 요청을 받을 경우
	> 요청된 url을 처리할 수 있는 servlet-mapping을 검색
		>> 검색되면: 해당 서블릿에 위임
		>> 검색안되면: default servlet에 위임(<url-pattern>/</url-pattern>)

   - spring dispatcherServlet
	> <url-pattern>/*.nhn</url-pattern>

   - url: /user/view
	> <url-pattern>/</url-pattern>





============================================[0917]============================================

ㅁ Spring Controller
   - 기존 서블릿 기반 개발 시: 여러개의 Controller를 생성하여 각각의 기능을 구현
   - 스프링 기반 개발 시: 하나의 Controller에서 메서드로 각각의 기능을 구현

ㅁ cp 설정(listener), ContextPath

   - .java 파일
	src/main/java kr.or.ddit.listener ContextPathInitListener.java

   - web.xml
	<!-- context path 설정: 서버 기동시 application scope에 cp라는 속성에 컨텍스트 패스값을 넣어준다 -->
	<listener>
		<listener-class>kr.or.ddit.listener.ContextPathInitListener</listener-class>
	</listener>

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ 개발에 유용한 내용 ==> SpringMvcController.java
	@RequestMapping("requestParam")
	public String requestParam( 
		@RequestParam(name = "userId") String user, // 파라미터의 name을 userId로 변경
		@RequestParam(defaultValue = "10") int page) // page의 기본값이 10이 된다.
	
	@RequestMapping("/path/{subpath}") // jsp에서 넘긴 값을 매핑으로 지정
	public String requestPath( @PathVariable(name = "subpath") String subpath)

ㅁ @Controller / @RequestMapping 파라미터
   - HttpServletRequest, HttpServletResponse, HttpSession
   - Map(==Model==ModelMap)
   - Command/form 객체 @ModelAttribute





============================================[0918]============================================

ㅁ 중요하진 않지만 유용한 기능
   - @ModelAttribute: 
		@RequestMapping이 붙은 메소드가 실행되기 전에 @ModelAttribute메소드가
		먼저 실행되고 해당 메소드가 리턴하는 값을 Model객체에 자동으로 넣어준다.
		(해당 컨트롤러에서만 사용가능)

	// 생성
	@ModelAttribute("rangers")
	public List<String> rangers() {
		List<String> rangers = new ArrayList<String>();
		rangers.add("brown");
		rangers.add("sally");
		rangers.add("cony");
		
		return rangers;
	}

	// 모델에 주입(방법1) ==> 형변환해야 함
	@RequestMapping("view")
	public String view(Model model) {
		List<String> rangers = (List<String>) model.asMap().get("rangers");
		logger.debug("rangers: {}", rangers);
		return "mvc/view";
	}

	// 직접 주입(방법2) ==> 더 사용하기 편함
	@RequestMapping("view")
	public String view(@ModelAttribute("rangers") List<String> rangers) {
		logger.debug("rangers: {}", rangers);
		return "mvc/view";
	}

   - @SessionAttributes: 
		@ModelAttribute는 계속 실행되는 반면 @SessionAttributes는 session에
		주입하여 부담이 줄어든다. (DB를 계속 조회를 할 경우 @ModelAttribute는 부담)

   - @GetMapping, @PostMapping: 
		@RequestMapping(path = "userListOnlyHalf", method = RequestMethod.GET)를
		@GetMapping("userListOnlyHalf")로 사용할 수 있다.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ 파일 업로드 File Upload
   - servlet기반 파일 업로드 설정
	1. form태그 enctype="multipart/form-data"
	2. @MultipartConfig
	3. Part part = request.getPart();

   - pom.xml
	<dependency>
		<groupId>commons-fileupload</groupId>
		<artifactId>commons-fileupload</artifactId>
		<version>1.4</version>
	</dependency>

   - servlet-context.xml <== src/main/resources config/spring
	<!-- multipartResolver -->
	<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		<property name="maxUploadSize" value="5242880"></property> <!-- 5MB -->	
		<property name="maxUploadSizePerFile" value="26214400"></property>	<!-- 25MB -->
	</bean>

   - view.jsp
	<form id="frmPart" action="${cp }/mvc/upload" enctype="multipart/form-data">
		<input type="text" name="userId" value="brown"/> <br>
		<input type="file" name="picture"/> <br>
		<input type="submit" value="전송"/>
	</form>

   - SpringMvcController.java
	@RequestMapping("upload")
	public String upload(String userId, @RequestPart("picture") MultipartFile partFile) {
		logger.debug("userId: {}", userId);
		logger.debug("partFile.getName(): {}", partFile.getName());
		logger.debug("partFile.getOriginalFilename(): {}", partFile.getOriginalFilename());
		
		// 업로드 되는 시점의 년/월 폴더를 생성해주고, 파일 경로와 파일 정보를 FileInfo객체에 담아 리턴
		FileInfo fileInfo = FileUtil.getFileInfo(partFile.getOriginalFilename());
		
		try { partFile.transferTo(fileInfo.getFile()); }
		catch (IllegalStateException | IOException e) { e.printStackTrace(); }
		
		return "mvc/view";
	}

	
   - FileInfo.java <== 파일업로드를 위해 만든 클래스(VO)
	public class FileInfo {
		private File file;		// 업로드 경로를 포함한 파일 객체
		private String originalFileName;// 업로드한 실제 파일명
		private String extName;		// 확장자 명(.포함)

		// 생성자
		public FileInfo(File file, String originalFileName, String extName)

		// getter, setter
		......
	}

   - FileUtil.java <== 파일업로드를 위해 만든 클래스(메서드)
	public class FileUtil {
		public static FileInfo getFileInfo(String originalFilename) {
			String path = getPath();
			
			String uuidFileName = UUID.randomUUID().toString();
			String extName = getExtension(originalFilename);
			File file = new File(path + "/" + uuidFileName + extName);
			FileInfo fileInfo = new FileInfo(file, originalFilename, extName);
			
			return fileInfo;
		}

		private static String getPath() {
			SimpleDateFormat sdf = new SimpleDateFormat("yyyyMM");
			String yyyyMM = sdf.format(new Date());
			String yyyy = yyyyMM.substring(0, 4);
			String mm = yyyyMM.substring(4, 6);
			
			String path = "e:/springUpload/" + yyyy + "/" + mm;
			
			File pathFile = new File(path);
			
			if(!pathFile.exists()) pathFile.mkdirs();
			
			return path;
		}
	
		private static String getExtension(String originalFilename) {
			String extName = "";
			if(originalFilename.contains("."))
				extName = originalFilename.substring(originalFilename.lastIndexOf("."));
			
			return extName;
		}
	}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ multi parameter
   - view.jsp
	<form action="${cp }/mvc/multiParameter" method="post">
		<input type="text" name="userId" value="brown"/> <br>
		<input type="text" name="userId" value="sally"/> <br>

		<input type="text" name="addr.addr1" value="대전시 중구 중앙로 76"> <br>
		<input type="text" name="addr.addr2" value="DDIT"> <br>

		<input type="text" name="addrList[0].addr1" value="대전시 중구 중앙로 76 list1"> <br>
		<input type="text" name="addrList[0].addr2" value="DDIT list1"> <br>
		
		<input type="text" name="addrList[1].addr1" value="대전시 중구 중앙로 76 list2"> <br>
		<input type="text" name="addrList[1].addr2" value="DDIT list2"> <br>

		<input type="submit" value="전송"/>
	</form>
 
   - SpringMvcController.java
	@RequestMapping("multiParameter")
	public String multiString(String userId,
				  @RequestParam("userId") List<String> userIdList, 
				  Main main) {
		// String으로 받기
		logger.debug("userId: {}", userId);
		// 결과 ==> userId: brown,sally
		
		// List로 받기
		logger.debug("userIdList: {}", userIdList);
		// 결과 ==> userIdList: [brown, sally]
		
		// VO로 받기
		logger.debug("main: {}", main);		
		// 결과 ==> main: Main [userId=[brown, sally], 
		//		addr=Addr [addr1=대전시 중구 중앙로 76, addr2=DDIT]]

		return "mvc/view";
	}

   - Main.java
	public class Main {
		private List<String> userId;
		private Addr addr;

		private List<Addr> addrList;

		// getter, setter
		.....

		// toString
		.....
	}

   - Addr.java
	public class Addr {
		private String addr1; // 도로주소
		private String addr2; // 상세주소

		// getter, setter
		.....

		// toString
		.....
	}
	
ㅁ POST방식에서 UTF-8설정(한글깨짐 설정)
   - web.xml <== maven 프로젝트의 web.xml
	<!-- character encoding filter -->
	<filter>
		<filter-name>characterEncodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>utf-8</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>characterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ redirect
   - SpringMvcController.java
	@RequestMapping("redirect")
	public String redirect(String userId, Model model, HttpSession session, RedirectAttributes reAttr) {
//		model.addAttribute("userId", userId);
//		session.setAttribute("userId", userId);
		
		// redirect시 최초 1회에 한해서 해당 속성값을 유지하고, 읽혀진 뒤 세션에서 해당 속성을 제거함.
		reAttr.addFlashAttribute("userId", userId); 
		
		// 리다이렉트시 파라미터로 전달
		reAttr.addAttribute("alias", "bear");

 		return "redirect:/login";
		// redierct: "redirect:url주소";
		// forward : "forward:url주소"; ==> 다른 컨트롤러로 forward (http method)에 대해 고려해야함
		// 원본 요청 get이면 forward 메소드 get (http method에 대해 고려해야함)
	}

   - view.jsp
	<form action="${cp }/mvc/redirect">
		<input type="text" name="userId" value="brown"/> <br>
		<input type="submit" value="전송"/>
	</form>

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ validator
   - UserValidator.java
	public class UserValidator implements Validator{
	
		@Override
		public boolean supports(Class<?> clazz) {
			return User.class.isAssignableFrom(clazz);
		}
	
		@Override
		public void validate(Object target, Errors errors) {
			User user = (User) target;
			//userId 필드는 null일수 없고, 문자열 길이는 4글자 이상이어야한다.
			if(user.getUserId() == null || user.getUserId().length() <= 3)
				errors.rejectValue("userId", "required");//필드명, 에러코드(개발자 정의)
		}
	
	}	

   - SpringMvcController.java
	@RequestMapping("validator")
	public String validator(User user, BindingResult result) {
		// form객체(command, vo)의 검증 결과를 담는 BindingResult객체는
		// 반드시 메소드 인자 순서에서 form객체 바로 뒤에 위치해야 된다.
		
		// validator 실행
		new UserValidator().validate(user, result);

		if(result.hasErrors()) logger.debug("has Error");
		else logger.debug("no Error");
		
		logger.debug("user: {}", user);

		return "mvc/view";
	}

    - view.jsp
	<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>

	...

	<form action="${cp }/mvc/validator">
		<input type="text" name="userId" value="brown">
		<form:errors path="user.userId"/> <br>
		<input type="text" name="userNm" value="브라운"> <br>
		<input type="submit" value="전송"/>
	</form>
 
   - error.properties <== src/main/resources kr/or/ddit/msg 
	> 프로퍼티 에디터 설치: help - dd -> add -> name: property editor /
	  link: http://propedit.sourceforge.jp/eclipse/updates -> PropertiesEditor 체크 -> 설치

	#에러코드.(객체명.) 필드=에러메세지
	required.userId=사용자 아이디는 null이거나 3글자 이하일 수 없습니다.

   - servlet-context.xml <== src/main/resources kr/or/ddit/config/spring 
	<!-- resource bundle -->
	<bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
		<property name="basenames">
			<list>
				<value>classpath:kr/or/ddit/config/msg/error</value>
			</list>
		</property>
	</bean>

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ jsr303(validator)
   - pom.xml
	<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator -->
	<dependency>
		<groupId>org.hibernate</groupId>
		<artifactId>hibernate-validator</artifactId>
		<version>5.4.3.Final</version>
	</dependency>

   - User.java <== vo
	...
	@NotNull
	private String pass;	// 사용자 비밀번호
	...

   - error.properties <== src/main/resources kr/or/ddit/msg 
	NotNull.pass=비밀번호는 반드시 입력해야 합니다.

   - view.jsp
	<form action="${cp }/mvc/jsr303">
		<input type="text" name="userId" value="brown"> <br>
		<input type="text" name="userNm" value="브라운"> <br>
		<input type="submit" value="전송"/> <form:errors path="user.pass"/>
	</form>

   - SpringMvcController.java
	@RequestMapping("jsr303")
	public String jsr303(@Valid User user, BindingResult result) {
		if(result.hasErrors()) 
			logger.debug("has Error");
		else 
			logger.debug("no Error");
		
		return "mvc/view";
	}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ 예외 ==> 컨트롤러마다 있어야 함.. 타입별로 해야 함.. 등의 문제점 ==> ControllerAdvice이용
   - SpringMvcController.java
	@RequestMapping("throwException")
	public String throwException() {
		int a = 10 / 0;
		
		return "mvc/view";
	}

	// CommonException.java로 이동함	
//	@ExceptionHandler({ArithmeticException.class}) // 예외 종류 선언
//	public String exceptionHandler() {
//		logger.debug("exceptionHandler()");
//		
//		return "error/arith";
//	}

   - arith.jsp <== WEB-INF/views/error
	<h1>arith.jsp</h1>

   - CommonException.java <== src/main/java kr.or.ddit.controllerAdvice
	@ControllerAdvice
	public class CommonException {

		private static final Logger logger = LoggerFactory.getLogger(CommonException.class);
	
		@ExceptionHandler({ArithmeticException.class}) // 예외 종류 선언
		public String exceptionHandler() {
			logger.debug("exceptionHandler()");
			
			return "error/arith";
		}
	}

   - servlet-context.xml <== src/main/resources kr/or/ddit/config/spring 
	<!-- @Controller 어노테이션이 붙은 클래스만 스캔 -->
	<context:component-scan base-package="kr.or.ddit" use-default-filters="false">
		<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	</context:component-scan>

	위 내용을 아래처럼 추가함

	<!-- @Controller, @ControllerAdvice 어노테이션이 붙은 클래스만 스캔 -->
	<context:component-scan base-package="kr.or.ddit" use-default-filters="false">
		<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
		<context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/>
	</context:component-scan>

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ ResponseStatus <== 사용자가 만드는 예외
   - NotFileException.java <== src/main/java kr.or.ddit.exception

   - SpringMvcController.java

ㅁ application 불러오기
   1. controller에서 메서드에 HttpServletRequest request를 인자로 넣어주기
   2. request를 이용해 application얻기
	ServletContext application = request.getServletContext();
   3. application에 데이터 넣기
	application.setAttribute("boardList", boardService.getBoardList());





============================================[0919]============================================

ㅁ Filter / AOP / Interceptor 비교
   - Filter
	> spring container에 포함되지 않음 -> 기본 설정에서는 DI 활용 불가
					(DelegatingFilterProxy 필터를 이용하면 가능)

   - AOP
	> 범용적
	> 일시적은 설정 보다는 어플리케이션 전반에 대한 설정에 적합

   - Interceptor
	> DI 가능 / 설정 간단
	> 요청에 대한 전후 처리에 적당
		>> 컨트롤러 실행 전(preHandle)
		>> 컨트롤러 실행 후(PostHandle)
		>> 뷰를 실행한 이후(afterCompletion)

ㅁ Interceptor 구현 방법
   - class 생성 ==> main/java kr.or.ddit.interceptor PerformanceCheckInterceptor.java
	> extends HandlerInterceptorAdapter
   	> 메소드 재정의
		>> preHandle
		>> postHandle
		>> afterCompletion

   - PerformanceCheckInterceptor.java 생성

   - bean 생성 ==> main/resources kr.or.ddit.config.spring context-interceptors.xml

   - web.xml
	<!-- 자동완성: ctrl + space -> dispatcherservlet -->
	<!-- The front controller of this Spring Web application, responsible for handling all application requests -->
	<servlet>
		<servlet-name>springDispatcherServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:kr/or/ddit/config/spring/servlet-context.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	의 내용을 아래와 같이 한줄 추가

	<!-- 자동완성: ctrl + space -> dispatcherservlet -->
	<!-- The front controller of this Spring Web application, responsible for handling all application requests -->
	<servlet>
		<servlet-name>springDispatcherServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>
				classpath:kr/or/ddit/config/spring/servlet-context.xml
				classpath:kr/or/ddit/config/spring/servlet-interceptors.xml
			</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	==> interceptors를 계속 불러오면 프로그래밍단계에서 귀찮으므로 주석해놨음.

ㅁ Interceptor를 이용해 SessionCheckFilter 구현 ==> SessionCheckInterceptor.java
   - context-interceptors.xml
	<mvc:interceptor>
		<mvc:mapping path="/**/"/>
		<mvc:exclude-mapping path="/login"/> <!-- 로그인 화면, 로그인 요청 -->
		<mvc:exclude-mapping path="/css/**"/>
		<mvc:exclude-mapping path="/js/**"/>
		<mvc:exclude-mapping path="/bootstrap/**"/>
		<mvc:exclude-mapping path="/error/**"/>
		<bean class="kr.or.ddit.interceptor.SessionCheckInterceptor"/>
	</mvc:interceptor>

   - SessionCheckInterceptor.java

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ JSON(JavaScript Object Notation)
	ex) var user = {userId : "brown", userNm : "브라운"};
	    user.userId ==> brown
	    var str = JSON.stringify(user) ==> {"userId":"brown"} // 문자열이 됨
	    JSON.parse(str) // json객체가 됨

ㅁ AJAX(Asynchronous JavaScript and XML)
	==> 옛날엔 xml파일로 했지만 데이터에 붙는 것들이 많아서 무거워짐
	==> XML방식: <books>
		   	   <book>
			      <title> 태백산맥 </title>
			      <author> 조정래 </author>
			   </book>
		     </books>

	==> json방식: {title: "태백산맥", author: "조정래"}

ㅁ jackson databind ( java object -> json )
   - pom.xml
	<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
	<dependency>
	    <groupId>com.fasterxml.jackson.core</groupId>
	    <artifactId>jackson-databind</artifactId>
	    <version>2.9.9.3</version>
	</dependency>

   - view resolver 추가 ==> servlet-context.xml
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="order" value="1"/> <!-- value가 낮을수록 우선순위가 높다. -->
	</bean>

	<!-- view resolver : beanNameViewResolver (order 0) -->
	<!-- controller가 리턴하는 viewName과 일치하는 spring bean이 있으면(view) 해당 view객체를 통해 응답을 생성하도록 한다. -->
	<bean class="org.springframework.web.servlet.view.BeanNameViewResolver">
		<property name="order" value="0"/>
	</bean>

	<!-- model객체에 있는 속성들을 json문자열로 응답을 생성 -->
	<bean name="jsonView" class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"></bean>

   - SpringMvcView.java
	@RequestMapping("jsonView") // 이게 더 좋은 방식
	public String jsonView(Model model) {
		List<String> rangers = new ArrayList<String>();
		rangers.add("brown");
		rangers.add("cony");
		rangers.add("sally");
		
		model.addAttribute("rangers", rangers);
		
		return "jsonView"; // servlet-context.xml에 정의했음
	}

	@RequestMapping("jsonView2") // 이게 더 별로인 방식
	public View jsonView2(Model model) { // org.springframework.web.servlet.View;
		List<String> rangers = new ArrayList<String>();
		rangers.add("brown");
		rangers.add("cony");
		rangers.add("sally");
		
		model.addAttribute("rangers", rangers);

		return new MappingJackson2JsonView();
	}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ FileDownloadView
   - FileDownloadView.java ==> main/java kr.or.ddit.view
	> extends AbstractView

	> renderMergedOutputModel 오버라이딩
	// model: 개발자가 controller메소드에서 등록한 속성들이 저장됨
	@Override
	protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,
			HttpServletResponse response) throws Exception {
		// 고정된 이미지를 응답으로 생성
		// 파일 전송임을 알려주는 헤더 정보 설정
		
		// 컨트롤러 메소드에서 추가한 속성
		String pictureName = (String)model.get("pictureName");
		
		if(pictureName == null) 
			pictureName = "noimage.png";
		
		response.setHeader("content-disposition", "attachment;filename=" + pictureName);
		response.setContentType("application/octet-stream"); // 바이너리로 요청이 전송됨
		
		File file = new File("e:/rangers/" + pictureName);
		FileInputStream fis = new FileInputStream(file);
		ServletOutputStream sos = response.getOutputStream();
		
		byte[] buffer = new byte[512];
		int len = 0;
		
		while( (len = fis.read(buffer, 0, 512)) != -1 ) {
			sos.write(buffer, 0, len);
		}
		
		fis.close();
	}

   - servlet-context.xml
	<!-- fileDownloadView: 고정된 이미지를 다운로드(sally.png) -->
	<bean name="fileDownloadView" class="kr.or.ddit.view.FileDownloadView"/>

   - SpringMvcController.java
	@RequestMapping("fileDownloadView")
	public String fileDownloadView() {
		return "fileDownloadView";
	}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ ajax를 이용해 json으로 페이징 리스트 출력
   - UserController.java
	> userPagingListAjax()
	> userPagingListAjaxView()

   - userPagingListAjaxView.jsp
	> ajax call을 통해 page, pagesize하는 사용자 데이터를 가져온다.
	function getUserList(page, pagesize) {
		$.ajax({
			url: "${cp}/user/userPagingListAjax",
			data: "page=" + page + "&pagesize=" + pagesize,
			success: function(data) {
				console.log(data);
			}
		});
	}

	> 	


	












































































