======================================[0909]======================================

ㅁ 스프링 설정파일 
   - .java파일
   - .xml + .java 
   - .xml파일
	> sts ==> https://spring.io/tools3/sts/all ==> windows 다운로드
	> B_Util - 3.Eclipse - sts-bundle - sts-3.9.9.RELEASE - STS.exe를 바탕으로
	> 경로: E:\A_TeachingMaterial\7.JspSpring\springworkspace

   - 201906eclipse에서 export - preferences - Export all 체크하고 
     파일명 jspsetting으로 finish

   - sts에서 import - preferences - Import all - 아까 export한 파일 선택 finish

   - sts를 사용하는 가장 큰 이유 ==> bean 선언하기에 편함(위자드를 제공함)

ㅁ Framework와 library의 차이
   - Library: 프로그램 호출에 의한 제어
	      정의된 대로 사용 ==> logger.debug()
              원본 Library 재정의 가능

   - Framework: 프로그램의 흐름이 프레임워크에 의해 제어
                기능 확장 가능
                Framework 자체는 수정불가(수정은 가능하지만 원본기능이 작동하지 않을 수 있다)

   - Framework를 사용하는 이유
	> 시스템의 기능외에 필요한 비기능 요소들을 제공받을 수 있다.
	  ==> 시스템 구축시마다 반복적으로 비기능 요소를 구현할 필요가 없다.
	      (비기능: DB connection 관리, transaction 제어)
	      (기능: 인사시스템의 사원정보 저장/조회/변경, 상담 시스템의 상담 내용 입력)
	> 비지니스 로직 구현에 집중할 수 있다.
	> 비기능 요소들을 직접 구현할 자신이 없다.

	> 장점: 구현/유지보수의 편이
	> 단점: 개발자들의 역량 획일화

	> 즉, 개발자들이 비지니스 로직에만 집중할 수 있도록 지원한다. 





======================================[0910]======================================

★ 현재 가지고 있는 지식으로 이해할 수 있도록 코드 작성 ★

ㅁ IOC(Inversion of Control): 제어의 역전, 모든 종류의 작업을 사용하는 쪽에서 제어

ㅁ 프로젝트 생성: 
   1. 위자드 - maven project - create a simple project 체크 -
      kr.or.ddit / spring / 0.0.1-SNAPSHOT / war - finish
   2. 프로젝트 우클릭 - java ee - generate deployment~~ - 생성된 web.xml의 버전을
      2.5에서 3.0으로 변경

ㅁ 테스트 코드 ==> 컨테이너를 사용하지만, 직접 만드는건 이번이 처음(예시임)
   - src/test/resources/kr/or/ddit/spring/ioc에서 Spring Bean Configuration File
     => application-context-test.xml
	<!--  name: 스프링 컨테이너에서 관리되는 객체의 이름 - 개발자가 작성 -->
	<!-- class: 해당 스프링 객체의 구현 클래스의 full name -->
	<bean name="boardDao" class="kr.or.ddit.test.board.dao.BoardDao"/>

	<!-- boardService라는 이름으로  kr.or.ddit.test.board.service.BoardService 클래스를 이용하여 스프링객체 생성-->
	<!-- BoardService 클래스의 boardDao필드(<property name>)에 boardDao라는 이름의 스프링 빈(<property ref>)을 주입 -->
	<bean name="boardService" class="kr.or.ddit.test.board.service.BoardService">
		<property name="boardDao" ref="boardDao"/>  <!-- 위에 적힌 boardDao를 주입 -->
		<property name="boardNm"  value="Q/A게시판"/> <!-- 문자열 Q/A게시판을 주입 -->
	</bean>

   - src/test/java/kr/or/ddit/board/dao => IBoardDao.java / BoardDao.java

   - src/test/java/kr/or/ddit/board => Main.java
	1. spring ioc 컨테이너를 이용한 객체 생성(객체를 만드는 설명서를 spring한테 위임)
	ApplicationContext context = new ClassPathXmlApplicationContext
		("classpath:kr/or/ddit/spring/ioc/application-context-test.xml");

	2. 스프링 컨테이너로(==ioc 컨테이너)부터 원하는 객체를 요청: DL(Dependency Lookup)
	IBoardDao cDao = (IBoardDao)context.getBean("boardDao");
	IBoardService cService = context.getBean("boardService", IBoardService.class);

ㅁ boardDao 구현체를 설정할 수 있는 방법
   1. 직접 만들기
	==> 생성자에서 new BoardDao() <-- jsp시간에 했으나 좋은 방식이 아님(분리가 힘듦)
   2. 외부에서 주입 
	==> .setter( setBoardDao(IBoardDao boardDao) )
	==> .constructor( public BoardService(IBoardDao boardDao) )

ㅁ DI: 컨테이너가 빈 설정 정보를 바탕으로 의존성을 고려하여 객체(bean)를 주입
	=> XML, java annotation 설정
	ex) boardService에 boardDao 객체 주입 => 많이 사용

ㅁ DL: 컨테이너에 설정된 빈을 참조
	ex) applicationContext객체로 부터 boardService객체를 참조 => 잘 사용 안함

ㅁ 명시적 트랜잭션: 개발자가 직접 commit하는 것 ==> sqlSession.commit();
   선언적 트랜잭션: 특정 예외시 자동으로 rollback, 아니면 commit

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

★ 앞으로 사용할 spring 코드 작성 ★

ㅁ Spring Annotation ==> junit 예시

// @Test 메소드가 실행되기 전에 제공한 조립 설명서를 바탕으로 스프링 컨테이너를 구축
// @Resource을 이용해서 junit클래스의 필드에 스프링 빈을 손쉽게 주입받을 수 있다.
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:kr/or/ddit/spring/ioc/application-context-test.xml")
public class SpringContainerTest {

	// name: 스프링 빈 이름
	// boardDao라는 이름의 스프링 빈을 스프링 컨테이너로부터 찾아 boardDao필드에 주입
	@Resource(name="boardDao")
	private IBoardDao boardDao;
	
	@Test
	public void boardDaoBeanTest() {
		assertNotNull(boardDao);
	}
}

ㅁ Bean의 scope ==> 기본값은 singleton
   - singleton: bean을 컨테이너에 하나씩만 생성
		spring컨테이너에서 같은 이름의 bean은 하나만 존재
		(디자인 패턴과 다르게 같은 클래스에서 다른 이름(id == name)을 갖는
		스프링 빈이 존재 가능)
   - prototype: bean을 요청할 때 마다 새로운 빈을 생성
   - request: http request마다 생성(WebApplicationContext에만 적용)
   - session: http session당 하나의 객체를 생성(WebApplicationContext에만 적용)

   * 4가지가 있지만, singleton만 사용함




























































- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 