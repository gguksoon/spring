======================================[0909]======================================

ㅁ 스프링 설정파일 
   - .java파일
   - .xml + .java 
   - .xml파일
	> sts ==> https://spring.io/tools3/sts/all ==> windows 다운로드
	> B_Util - 3.Eclipse - sts-bundle - sts-3.9.9.RELEASE - STS.exe를 바탕으로
	> 경로: E:\A_TeachingMaterial\7.JspSpring\springworkspace

   - 201906eclipse에서 export - preferences - Export all 체크하고 
     파일명 jspsetting으로 finish

   - sts에서 import - preferences - Import all - 아까 export한 파일 선택 finish

   - sts를 사용하는 가장 큰 이유 ==> bean 선언하기에 편함(위자드를 제공함)

ㅁ Framework와 library의 차이
   - Library: 프로그램 호출에 의한 제어
	      정의된 대로 사용 ==> logger.debug()
              원본 Library 재정의 가능

   - Framework: 프로그램의 흐름이 프레임워크에 의해 제어
                기능 확장 가능
                Framework 자체는 수정불가(수정은 가능하지만 원본기능이 작동하지 않을 수 있다)

   - Framework를 사용하는 이유
	> 시스템의 기능외에 필요한 비기능 요소들을 제공받을 수 있다.
	  ==> 시스템 구축시마다 반복적으로 비기능 요소를 구현할 필요가 없다.
	      (비기능: DB connection 관리, transaction 제어)
	      (기능: 인사시스템의 사원정보 저장/조회/변경, 상담 시스템의 상담 내용 입력)
	> 비지니스 로직 구현에 집중할 수 있다.
	> 비기능 요소들을 직접 구현할 자신이 없다.

	> 장점: 구현/유지보수의 편이
	> 단점: 개발자들의 역량 획일화

	> 즉, 개발자들이 비지니스 로직에만 집중할 수 있도록 지원한다. 





======================================[0910]======================================

★ 현재 가지고 있는 지식으로 이해할 수 있도록 코드 작성 ★

ㅁ IOC(Inversion of Control): 제어의 역전, 모든 종류의 작업을 사용하는 쪽에서 제어

ㅁ 프로젝트 생성: 
   1. 위자드 - maven project - create a simple project 체크 -
      kr.or.ddit / spring / 0.0.1-SNAPSHOT / war - finish
   2. 프로젝트 우클릭 - java ee - generate deployment~~ - 생성된 web.xml의 버전을
      2.5에서 3.0으로 변경

ㅁ 테스트 코드 ==> 컨테이너를 사용하지만, 직접 만드는건 이번이 처음(예시임)
   - src/test/resources/kr/or/ddit/spring/ioc에서 Spring Bean Configuration File
     => application-context-test.xml
	<!--  name: 스프링 컨테이너에서 관리되는 객체의 이름 - 개발자가 작성 -->
	<!-- class: 해당 스프링 객체의 구현 클래스의 full name -->
	<bean name="boardDao" class="kr.or.ddit.test.board.dao.BoardDao"/>

	<!-- boardService라는 이름으로  kr.or.ddit.test.board.service.BoardService 클래스를 이용하여 스프링객체 생성-->
	<!-- BoardService 클래스의 boardDao필드(<property name>)에 boardDao라는 이름의 스프링 빈(<property ref>)을 주입 -->
	<bean name="boardService" class="kr.or.ddit.test.board.service.BoardService">
		<property name="boardDao" ref="boardDao"/>  <!-- 위에 적힌 boardDao를 주입 -->
		<property name="boardNm"  value="Q/A게시판"/> <!-- 문자열 Q/A게시판을 주입 -->
	</bean>

   - src/test/java/kr/or/ddit/board/dao => IBoardDao.java / BoardDao.java

   - src/test/java/kr/or/ddit/board => Main.java
	1. spring ioc 컨테이너를 이용한 객체 생성(객체를 만드는 설명서를 spring한테 위임)
	ApplicationContext context = new ClassPathXmlApplicationContext
		("classpath:kr/or/ddit/spring/ioc/application-context-test.xml");

	2. 스프링 컨테이너로(==ioc 컨테이너)부터 원하는 객체를 요청: DL(Dependency Lookup)
	IBoardDao cDao = (IBoardDao)context.getBean("boardDao");
	IBoardService cService = context.getBean("boardService", IBoardService.class);

ㅁ boardDao 구현체를 설정할 수 있는 방법
   1. 직접 만들기
	==> 생성자에서 new BoardDao() <-- jsp시간에 했으나 좋은 방식이 아님(분리가 힘듦)
   2. 외부에서 주입 
	==> .setter( setBoardDao(IBoardDao boardDao) )
	==> .constructor( public BoardService(IBoardDao boardDao) )

ㅁ DI: 컨테이너가 빈 설정 정보를 바탕으로 의존성을 고려하여 객체(bean)를 주입
	=> XML, java annotation 설정
	ex) boardService에 boardDao 객체 주입 => 많이 사용

ㅁ DL: 컨테이너에 설정된 빈을 참조
	ex) applicationContext객체로 부터 boardService객체를 참조 => 잘 사용 안함

ㅁ 명시적 트랜잭션: 개발자가 직접 commit하는 것 ==> sqlSession.commit();
   선언적 트랜잭션: 특정 예외시 자동으로 rollback, 아니면 commit

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

★ 앞으로 사용할 spring 코드 작성 ★

ㅁ Spring Annotation ==> junit 예시

// @Test 메소드가 실행되기 전에 제공한 조립 설명서를 바탕으로 스프링 컨테이너를 구축
// @Resource을 이용해서 junit클래스의 필드에 스프링 빈을 손쉽게 주입받을 수 있다.
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:kr/or/ddit/spring/ioc/application-context-test.xml")
public class SpringContainerTest {

	// name: 스프링 빈 이름
	// boardDao라는 이름의 스프링 빈을 스프링 컨테이너로부터 찾아 boardDao필드에 주입
	@Resource(name="boardDao")
	private IBoardDao boardDao;
	
	@Test
	public void boardDaoBeanTest() {
		assertNotNull(boardDao);
	}
}

ㅁ Bean의 scope ==> 기본값은 singleton
   - singleton: bean을 컨테이너에 하나씩만 생성
		spring컨테이너에서 같은 이름의 bean은 하나만 존재
		(디자인 패턴과 다르게 같은 클래스에서 다른 이름(id == name)을 갖는
		스프링 빈이 존재 가능)
   - prototype: bean을 요청할 때 마다 새로운 빈을 생성
   - request: http request마다 생성(WebApplicationContext에만 적용)
   - session: http session당 하나의 객체를 생성(WebApplicationContext에만 적용)

   * 4가지가 있지만, singleton만 사용함

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ annotation-base
   - 모든 빈을 명시적으로 기술하는데는 비용이 크다.
   - base패키지 하위에 속한 클래스 중 @Controller, @Service, @Repository, @Component
     어노테이션이 설정을 확인하여 spring bean으로 자동으로 등록해준다.
   - annotation-config를 통해 다음의 어노테이션을 처리하는 BeanPostProcessor 등록을
     간편하게 할 수 있다.

<beans ......>
	<context:component-scan base-package="kr.or.ddit, kr.or.ccit"/>

	<!-- 스캔 이후에 @Resource 어노테이션에 대한 후처리 -->	
	<context:annotation-config/>

	<!--
	  <bean>엘레멘트를 이용하여 스프링 빈으로 등록하던 방식에서 
	  특정 패키지 이하의 클래스를 스캔하며 @Controller, @Service, @Repository, @Component
	  어노테이션이 붙은 클래스들을 자동으로 스프링 빈으로 생성
	 -->
	<context:component-scan base-package="kr.or.ddit"/>

	<!--
	   스캔 이후에 @Resource, @Autowired, @Qualifier, @Required,
	   @PostConstruct, @PreDestory, @Configuration 어노테이션에 대한 후처리
	   (수업시간엔 대부분 @Resource만 사용할 예정) 
	-->	
	<context:annotation-config/>
</beans>

   * @Resource(name="boardDao") <== BoardDao클래스를 사용하는 방법(첫글자 소문자)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ 자바 클래스를 스프링 설정파일로 만들기
   * component-scan을 사용하는 것과 자바 클래스를 사용하는 두 가지 방법에 대해
     알고 있어야 한다.

	@Configuration
	@ComponentScan(basePackages = "kr.or.ddit")
	public class ApplicationJavaConfigScanT1 { } 





======================================[0911]======================================

ㅁ spring에서의 형변환 문제
   - xml 설정 파일에서 value속성을 주입할 때
     <bean id="xxx" class="zz.aa.Class">
	<property name="userId" value="brown"/>
	<property name="reg_dt" value="2019-08-08"/>
     </bean>

   - spring web mvc모듈에서 파라미터를 command객체(from객체, vo)로 자동 바인딩시
     형변환 문제가 발생(파라미터는 문자열 -> command객체의 date필드에 주입)

   - 해결책 3가지
	> propertyEditor
	> conversionService
	> formatting conversionService <-- 주로 사용함

ㅁ propertyEditor (kr.or.ddit.type => CustomDatePropertyEditor.java)
   - 클래스에 PropertyEditorRegistar인터페이스 구현하기
   - quick pix를 통해 registerCustomEditors메서드를 생성
   - 메서드 내부에 
	registry.registerCustomEditor(
		Date.class, new CustomDateEditor(
			new SimpleDateFormat("yyyy-MM-dd"), true
		)
	);
   - bean
	<bean name="customEditorConfigurer" class="org.springframework.beans.factory.config.CustomEditorConfigurer">
		<property name="propertyEditorRegistrars">
			<list>
				<bean class="kr.or.ddit.type.CustomDatePropertyEditor"/>
			</list>
		</property>
	</bean>

ㅁ conversionService (kr.or.ddit.type => CustomDateConverter.java)
   - bean
	<bean name="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
		<property name="converters">
			<set>
				<bean class="kr.or.ddit.type.CustomDateConverter"/>
			</set>
		</property>
	</bean>
   - 클래스에 Converter<String, Date>인터페이스 구현하기
		==> org.springframework.core.convert.converter.Converter   
   - quick pix를 통해 convert메서드를 생성
   - 메서드 내부에
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		
	try {
		return sdf.parse(source);
	} catch (ParseException e) {
		e.printStackTrace();
	}
	
	return null;

ㅁ formatting conversionService
   - bean
   <bean name="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
   
   - vo
   @DateTimeFormat(pattern="yyyy-MM-dd")
   private Date reg_dt;

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

★ IOC 끝

1. 프로젝트 신규생성
2. pom, gitignore, logback.xml 설정파일 복사
3. userDao, userService
   - xml: <bean>, scan
   - java: @Bean, scan

★ 위 사항의 테스트코드를 정상적으로 생성하여 테스트 코드를 통과하게끔 연습할 것

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ AOP(Aspect Oriented Programming): 여러 클래스로 분산된 책임(기능)을 별도의 관점
				     으로 분리/캡슐화 하는 프로그래밍 방법
   - 로직을 실행하기에 앞서 넣어주고 싶은 비기능 로직을 작성하지 않고 개발한 뒤
     AOP가 알아서 소스코드에 비기능 로직을 넣어서 컴파일? 시켜준다.
   - AOP는 OOP(객체지향프로그래밍)를 대체하는 개념이 아닌 보완하는 개념

   - pom.xml
	<!-- AOP: https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
	<dependency>
		<groupId>org.aspectj</groupId>
		<artifactId>aspectjweaver</artifactId>
		<version>1.9.4</version>
	</dependency>

   - ProfilingAspect.java
	public void befor(JoinPoint joinPoint) { // ==> org.aspectj.lang.JoinPoint
		logger.debug("profilingAspect.befor()");
	}

   - application-context-aop-test.xml

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ 트랜잭션
   - 선언적 트랜잭션 관리
	> 소스코드상에서 트랜잭션을 제어하지 않음
	> 설정을 통해 일괄적으로 트랜잭션을 제어(xml: tx, java: annotation)

ㅁ jdbc
   - pom.xml
	<!-- mybatis: https://mvnrepository.com/artifact/org.mybatis/mybatis -->
	<dependency>
		<groupId>org.mybatis</groupId>
		<artifactId>mybatis</artifactId>
		<version>3.5.2</version>
	</dependency>

	<!-- mybatis-spring: https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->
	<dependency>
		<groupId>org.mybatis</groupId>
		<artifactId>mybatis-spring</artifactId>
		<version>2.0.2</version>
	</dependency>

	<!-- dbcp: https://mvnrepository.com/artifact/org.apache.commons/commons-dbcp2 -->
	<dependency>
		<groupId>org.apache.commons</groupId>
		<artifactId>commons-dbcp2</artifactId>
		<version>2.7.0</version>
	</dependency>

   - context-datasource.xml <== src/main/resource /kr/or/ddit/config/spring
	// namespaces: context
	<context:property-placeholder location="classpath:kr/or/ddit/config/mybatis/db.properties"/>
	<bean name="datasource" class="org.apache.commons.dbcp2.BasicDataSource">
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.user}"/>
		<property name="password" value="${jdbc.pass}"/>
	</bean>

	<bean name="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="datasource"/> <!-- bean 주입 -->
		<property name="configLocation" value="classpath:kr/or/ddit/config/mybatis/mybatis-config.xml"/>
	</bean>
	
	<bean name="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
		<constructor-arg ref="sqlSessionFactory"/>
	</bean>

   - context-transaction.xml <== src/main/resource /kr/or/ddit/config/spring
	// namespaces: aop, tx
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="datasource"/> <!-- datasource는 context-datasource.xml에 있음 -->
	</bean>
	
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<!-- 메소드 이름별로 트랜잭션에 대한 세부설정 -->
			<tx:method name="*" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>

	<aop:config>
		<aop:advisor advice-ref="txAdvice" pointcut="execution(* kr.or.ddit..service.*.*(..))"/>
	</aop:config>

   - context-root.xml <== src/main/resource /kr/or/ddit/config/spring
	// namespaces: context
	<context:component-scan base-package="kr.or.ddit">
	</context:component-scan>
	
	<context:annotation-config/>

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 












































































































































































